/* MQTT client details: */
let broker = {
  hostname: '192.168.1.34',
  port: 1884,
  clientID: 'p5canvas'
};

/* Define topic to subscribe to: */
let subTopic = '/itsy/#';
/* Define topic to publish to: */
let pubTopic = '/canvasSize';

/* Create MQTT client: */
client = new Paho.MQTT.Client(broker.hostname, Number(broker.port), broker.clientID);

/* Client callback handlers: */
client.onConnectionLost = onConnectionLost;
client.onMessageArrived = onMessageArrived;

/* MQTT Variable Declarations */
let messageSent = "";
let reloadTime = 20;
let errorMsg = "";
let crashInterval;

/* My Code Variable Declarations */
let item;
let x = 0; let y = 0;
let goLeft = false;
let goRight = false;
let goUp = false;
let goDown = false;
let still = false;
let move = 2;
let xoff = 0; let yoff = 0;
let state = 0;
let oldPrevW = 350/3; let oldPrevH = 500/3;
let prevW = 350/3; let prevH = 500/3;
var mid_value;

/* preloading images so to make make the animation smooth */
function preload(){
  item = loadImage('http://localhost:8080/beach.jpg') //loadImage("beach.jpg");
}

/* setup */
function setup() {
  winW = 350; //change to whatever we need
  winH = 500; // change to whatever we need
  createCanvas(winW, winH);
  background(0);
  client.connect({
    onSuccess: onConnect,
    useSSL: false
  });
}


function draw() {

// constrains
  if(x>item.width){
    x = item.width;
  }
  if(y>item.height){
    y = item.height;
  }

/* setting up digital item */
  background(220);
  image(item, 0, 0, winW, winH, x, y, prevW, prevH);

/* agency */


/* interaction */
  if(state === "left"){
    if(x>0){
      x -= move;
      console.log("go left");
    }
  }
  else if(state === "right"){
    if(x<item.width-prevW){
      x += move;
      console.log("go right");
    }
  }
  else if(state === "up"){
    if(y>0){
      y -= move;
      console.log("go up");
    }
  }
  else if(state === "down"){
    if(y<item.height-prevH){
      y += move;
      console.log("go down");
    }
  }
  else if(state === "still"){
      y = y;
      x = x;
      console.log("stand still");
  }

  if(state !== "0"){
    xoff = x;
    yoff = y;
  }

  else if(state === "0"){
//    filter(BLUR,5);
    x = map(noise(xoff), 0, 1, 0, (item.width));
    y = map(noise(yoff), 0, 1, 0, (item.height));
    xoff += 0.01;
    yoff += 0.01;
  }

  if(mid_value > 46000){
  mid_value = 46000
}
  if(mid_value < 18000){
  mid_value = 18000
}
  zoom = map(mid_value,46000,18000, 1, 2);
  prevW = zoom * oldPrevW;
  prevH = zoom * oldPrevH;
//  item.resize(zoomW, zoomH);
  console.log("mid val =", mid_value);
  console.log("zoom =", zoom);
//  console.log("prevW =", prevW);
//  console.log("prevH =", prevH);

}



/*-----------------------------// CALLBACK FUNCTIONS //------------------------------*/

/* Called when connection is established */
function onConnect() {
  // Once a connection has been made, send a message.
  console.log("Connected to mosquitto!");
  client.subscribe(subTopic);
  sendMessage(winW + "x" + winH, pubTopic);
}

/* Called when connection drops */
function onConnectionLost(responseObject) {
  if (responseObject.errorCode !== 0) {
    errorMsg = responseObject.errorMessage;
    console.log("onConnectionLost:" + errorMsg);
    crashInterval = setInterval(crashReload, 1000);
  }
}

/* Called when a message arrives */
function onMessageArrived(message) {
//  console.log(message.topic+" ");
  if(message._getDestinationName() == "/itsy/agency"){
    agency_value = split(trim(message.payloadString), "/");
    a(message.payloadString);
  }
  if(message._getDestinationName() == "/itsy/left"){
    left_value = split(trim(message.payloadString), "/");
    a(message.payloadString);
    //console.log("left sensor:", left_value)
  }
  if(message._getDestinationName() == "/itsy/right"){
    right_value = split(trim(message.payloadString), "/");
    a(message.payloadString);
    //console.log("right sensor:", right_value)
  }
  if(message._getDestinationName() == "/itsy/up"){
    up_value = split(trim(message.payloadString), "/");
    a(message.payloadString);
    //console.log("left sensor:", left_value)
  }
  if(message._getDestinationName() == "/itsy/down"){
    down_value = split(trim(message.payloadString), "/");
    a(message.payloadString);
    //console.log("right sensor:", right_value)
  }
  if(message._getDestinationName() == "/itsy/mid"){
    mid_value = split(trim(message.payloadString), "/");
    a(message.payloadString);
    //console.log("mid ensor:", mid_value)
  }
}
/*----------------------------------// FUNCTIONS //----------------------------------*/

/* Send message */
function sendMessage(msg, tpc) {

  messageSent=msg;
  console.log("Sending Message:\t[ "+ msg + " ]\nTo Topic:\t\t[ " + tpc +" ]");

  let message = new Paho.MQTT.Message(msg);
  message.destinationName = tpc;
  client.send(message);

}

/* Reload MQTT and canvas */
function crashReload() {

  background(255,0,0);
  fill(0);
  noStroke();
  textSize(36);
  textAlign(CENTER);
  text("AN ERROR OCCURRED! \n CANVAS RELOADING IN " + reloadTime + " SECONDS!", width/2, 100);
  textSize(16);
  text(errorMsg, width/2, 220);

  reloadTime--;

  if (reloadTime < 0) {
    clearInterval(crashInterval);
    reloadTime = 20;

    if (!client.isConnected()) {
      client.connect({
        onSuccess: onConnect,
        useSSL: false
      });
    }
    background(0);
  }
}


/* read messaged */
  function a (message){
    if (message == "aOn"){
      state = "0";
      console.log("state 0");
    }
    else if (message == "goLeft"){
      state = "left";
      console.log("go left");
      }
    else if (message == "goRight"){
      state = "right";
      console.log("go right");
      }
    else if (message == "goUp"){
      state = "up";
      console.log("go up");
      }
    else if (message == "goDown"){
      state = "down";
      console.log("go down");
      }
    else if (message == "still"){
      state = "still";
      console.log("stand still");
      }
    }


/*-----------------------------------------------------------------------------------*/
